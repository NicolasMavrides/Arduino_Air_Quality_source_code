/* Off-grid Air Quality Monitor dissertation project 
   Source code for Prototype 4
   Written by Nicolas Mavrides, academic year 2018 - 19
   Supervised by Prof Hamish Cunningham
   Department of Computer Science

   Code written with the hep of borrowed examples from the Arduino-lmic library and
   COM3505 labs by Hamish Cunningham and ideas inspired by the following 
   Adafruit.com tutorial: https://learn.adafruit.com/the-things-network-for-feather

   Code for ESP32 web server also written also with the help of the COM3505 lab class
   (week 5), and also with the help of the following tutorials/forums:
   https://randomnerdtutorials.com/esp32-access-point-ap-web-server/
   https://forum.arduino.cc/index.php?topic=94861.0
*/

#include <lmic.h>
#include <hal/hal.h>
#include <SPI.h>
#include <GP2Y1010_DustSensor.h> // Library for the Sharp dust sensor
#include <WiFi.h>
#include <WiFiClient.h>
#include <DHTesp.h>              // Library for temperature / humidity sensor
#include "AdafruitIO_WiFi.h"

// Adafruit IO credentials (used when WiFi is enabled)
// NOTE: credentials redacted for security reasons (can be any arbitrary credentials)
#define ADAFRUIT_IO_USER    "REDACTED"
#define ADAFRUIT_IO_KEY     "REDACTED"

AdafruitIO_WiFi io(ADAFRUIT_IO_USER, ADAFRUIT_IO_KEY, "", ""); // Dynamic WiFi name and password blank for now

// Create AdafruitIO feeds for readings (used only with WiFi as per above)
AdafruitIO_Feed *temperatureFeed = io.feed("Temperature");
AdafruitIO_Feed *humidityFeed = io.feed("Humidity");
AdafruitIO_Feed *pollutantsFeed = io.feed("Pollutants");
AdafruitIO_Feed *dustFeed = io.feed("Dust levels");

// Sensor object definitions for dust and dht sensors
GP2Y1010_DustSensor dustsensor;
DHTesp dht; // Declaring the Temperature and Humidity sensor

// Set up sensor pins and connection settings *****************************************
const int DustLEDPin = 21;
const int dhtPin = 14;
const int MQgasSensorPin = A7; //32
const int DustPin = A9; //33

// Set up WiFi Access Point credentials and other details *****************************
const char *ssid = "Air_Quality";   // Access point name
const char *password = "123456789"; // Password for AP
String wifi_name = "";              // WiFi network name (to be chosen by user in Web Server
String wifi_pass = "";              // WiFi network password (to be chosen as above)

int wifiButton = 4;
int wifiLED = 27; 
bool wifiOn = false;    // global bool for ESP to know whether WiFi is to be used or not
int wifiButtonMode = 1; // button mode for turning WiFi on/off (1 by default/when not pressed)

// Web-Server related variables *******************************************************
String header;         // for HTTP requests
WiFiServer server(80); // port for web server to listen on

// Device MAC address *****************************************************************
uint64_t chipid;                 // init uint for MAC address

// Sensor reading variables ***********************************************************
short gasSensorValue = 0;        // value read from gas sensor
int gasSensorValPPM = 0;         // gas sensor value after conversion to PPM
short dustSensorValue = 0;       // value read from dust sensor

short gasSensorValues = 0;       // sum of 10 gas sensor readings to get average
short dustSensorValues = 0;      // sum of 10 dust sensor readings to get average

short avGasSensorValue = 0;      // average of gasSensorValues
short avGasSensorValuePPM = 0;   // average of gasSensorValues
short avDustSensorValue = 0;     // average of dustSensorValues

int8_t temperature = 0;          // values read from temperature
int8_t humidity = 0;             // and humidity sensor

int temperatureValues = 0;       // sum of 10 temperature readings to get average
int humidityValues = 0;          // sum of 10 humidity readings to get average

int8_t avTemperatureValue = 0;   // average of temperatureValues
int8_t avHumidityValue = 0;      // average of humidityValues

// NOTE: NWKSKEY, APPSKEY AND DEVADDR REDACTED FOR SECURITY REASONS. REPLACE WITH CREDENTIALS GENERATED BY TTN APP TO BE USED
// LoRaWAN NwkSKey, network session key
static const PROGMEM u1_t NWKSKEY[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

// LoRaWAN AppSKey, application session key
static const u1_t PROGMEM APPSKEY[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

// LoRaWAN end-device address (DevAddr)
// See http://thethingsnetwork.org/wiki/AddressSpace
// The library converts the address to network byte order as needed.
static const u4_t DEVADDR = 0x00000000;

// These callbacks are only used in over-the-air activation, so they are
// left empty here (we cannot leave them out completely unless
// DISABLE_JOIN is set in arduino-lmic/project_config/lmic_project_config.h,
// otherwise the linker will complain).
void os_getArtEui (u1_t* buf) { }
void os_getDevEui (u1_t* buf) { }
void os_getDevKey (u1_t* buf) { }

static uint8_t mydata[8];
static osjob_t sendjob;

// Schedule TX every this many seconds (might become longer due to duty
// cycle limitations).
const unsigned TX_INTERVAL = 60;

// Pin mapping
// Adapted for Adafruit HUZZAH32
const lmic_pinmap lmic_pins = {
    .nss = A0,
    .rxtx = LMIC_UNUSED_PIN,
    .rst = A1,
    .dio = {39, 34, LMIC_UNUSED_PIN}, // using dio0 and dio1 radio pins
};

void onEvent (ev_t ev) {
    Serial.print(os_getTime());
    Serial.print(": ");
    switch(ev) {
        case EV_SCAN_TIMEOUT:
            Serial.println(F("EV_SCAN_TIMEOUT"));
            break;
        case EV_BEACON_FOUND:
            Serial.println(F("EV_BEACON_FOUND"));
            break;
        case EV_BEACON_MISSED:
            Serial.println(F("EV_BEACON_MISSED"));
            break;
        case EV_BEACON_TRACKED:
            Serial.println(F("EV_BEACON_TRACKED"));
            break;
        case EV_JOINING:
            Serial.println(F("EV_JOINING"));
            break;
        case EV_JOINED:
            Serial.println(F("EV_JOINED"));
            break;
        case EV_JOIN_FAILED:
            Serial.println(F("EV_JOIN_FAILED"));
            break;
        case EV_REJOIN_FAILED:
            Serial.println(F("EV_REJOIN_FAILED"));
            break;
        case EV_TXCOMPLETE:
            Serial.println(F("EV_TXCOMPLETE (includes waiting for RX windows)"));
            if (LMIC.txrxFlags & TXRX_ACK)
              Serial.println(F("Received ack"));
            if (LMIC.dataLen) {
              Serial.println(F("Received "));
              Serial.println(LMIC.dataLen);
              Serial.println(F(" bytes of payload"));
            }
            // Schedule next transmission
            os_setTimedCallback(&sendjob, os_getTime()+sec2osticks(TX_INTERVAL), do_send);
            break;
        case EV_LOST_TSYNC:
            Serial.println(F("EV_LOST_TSYNC"));
            break;
        case EV_RESET:
            Serial.println(F("EV_RESET"));
            break;
        case EV_RXCOMPLETE:
            // data received in ping slot
            Serial.println(F("EV_RXCOMPLETE"));
            break;
        case EV_LINK_DEAD:
            Serial.println(F("EV_LINK_DEAD"));
            break;
        case EV_LINK_ALIVE:
            Serial.println(F("EV_LINK_ALIVE"));
            break;
      } 
}


void setup() {
    delay(1000); // "nudge" time for ESP to wake up after deep-sleep
    
    while (!Serial); // wait for Serial to be initialized
    Serial.begin(115200);
    //delay(100);     // per sample code on RF_95 test
    Serial.println(F("Starting"));
    
    // WiFi button and WiFi LED
    pinMode(wifiButton, INPUT_PULLUP);           // init WiFi button
    pinMode(wifiLED, OUTPUT);                    // and WiFi LED
    // sensors pins
    pinMode(32, INPUT);
    pinMode(33, INPUT);
    pinMode(12, INPUT);

    // Sensors init
    dht.setup(dhtPin, DHTesp::AM2302);  
    dustsensor.begin(DustLEDPin, DustPin);
    dustsensor.setInputVolts(5);   // Voltage for dust sensor set to 5V
    dustsensor.setADCbit(12);      // ADCbit set to 12 bits as we are using ESP32

    wifiButtonMode = digitalRead(wifiButton);    // is WiFi turned on or off?
    
    /* ESP32 will flash LED 10 times. User must press WiFi button within this
       period if they wish to use the ESP web server and WiFi for sending the
       data. If the button is not pressed within the period, the device will
       default to using LoRaWAN for sending the data. The flash interval will
       however repeat after the device wakes up again from deep-sleep mode, and
       the user will have the chance to opt for WiFi again.
    */

    for (int x = 0; x < 10; x++) {              // produce a 10-iteration LED flash
      digitalWrite(wifiLED, HIGH);
      delay(500);
      wifiButtonMode = digitalRead(wifiButton); // check button status (1 = not pressed)      
      if (wifiButtonMode == 1) {                 
        digitalWrite(wifiLED, LOW);             // complete flash
        wifiOn = false;                         // set variable accordingly
      } else {   
        // button pressed                               
        digitalWrite(wifiLED, HIGH);            // keep LED on
        x = 10;                                 // break the loop
        wifiOn = true;                          // set variable accordingly
      }
      
      delay(500);
    }

    // Otherwise, if WiFi hasn't been activated, initialise LoRaWAN
    if (wifiOn == false) {
      // LMIC init
      Serial.println("os initialising...");
      os_init();
      Serial.println("os init complete!");
      // Reset the MAC state. Session and pending data transfers will be discarded.
      LMIC_reset();
  
      // Set static session parameters. Instead of dynamically establishing a session
      // by joining the network, precomputed session parameters are be provided.
      #ifdef PROGMEM
      // On AVR, these values are stored in flash and only copied to RAM
      // once. Copy them to a temporary buffer here, LMIC_setSession will
      // copy them into a buffer of its own again.
      uint8_t appskey[sizeof(APPSKEY)];
      uint8_t nwkskey[sizeof(NWKSKEY)];
      memcpy_P(appskey, APPSKEY, sizeof(APPSKEY));
      memcpy_P(nwkskey, NWKSKEY, sizeof(NWKSKEY));
      LMIC_setSession (0x13, DEVADDR, nwkskey, appskey);
      #else
      // If not running an AVR with PROGMEM, just use the arrays directly
      LMIC_setSession (0x13, DEVADDR, NWKSKEY, APPSKEY);
      #endif
      
      #if defined(CFG_eu868)  // Check if the EU config settings are set
      // (Region-specific config settings are set in the lmic library)
      // Set up the channels used by the Things Network, which corresponds
      // to the defaults of most gateways. Without this, only three base
      // channels from the LoRaWAN specification are used, which certainly
      // works, so it is good for debugging, but can overload those
      // frequencies, so be sure to configure the full frequency range of
      // your network here (unless your network autoconfigures them).
      // Setting up channels should happen after LMIC_setSession, as that
      // configures the minimal channel set.
      Serial.println("EU region configuration specified.");
      
      LMIC_setupChannel(0, 868100000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
      LMIC_setupChannel(1, 868300000, DR_RANGE_MAP(DR_SF12, DR_SF7B), BAND_CENTI);      // g-band
      LMIC_setupChannel(2, 868500000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
      LMIC_setupChannel(3, 867100000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
      LMIC_setupChannel(4, 867300000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
      LMIC_setupChannel(5, 867500000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
      LMIC_setupChannel(6, 867700000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
      LMIC_setupChannel(7, 867900000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
      LMIC_setupChannel(8, 868800000, DR_RANGE_MAP(DR_FSK,  DR_FSK),  BAND_MILLI);      // g2-band
      
      // TTN defines an additional channel at 869.525Mhz using SF9 for class B
      // devices' ping slots. LMIC does not have an easy way to define set this
      // frequency and support for class B is spotty and untested, so this
      // frequency is not configured here.
      #elif defined(CFG_us915)
      // NA-US channels 0-71 are configured automatically
      // but only one group of 8 should (a subband) should be active
      // TTN recommends the second sub band, 1 in a zero based count.
      // https://github.com/TheThingsNetwork/gateway-conf/blob/master/US-global_conf.json
      LMIC_selectSubBand(1);
      #endif
      
      // Disable link check validation
      LMIC_setLinkCheckMode(0);
  
      // TTN uses SF9 for its RX2 window.
      LMIC.dn2Dr = DR_SF9;
  
      // Set data rate and transmit power for uplink (note: txpow seems to be ignored by the library)
      LMIC_setDrTxpow(DR_SF7,14);
      
      // Start data transmission job
      do_send(&sendjob);
    
    } else {
      /* As above, if WiFi has been activated, setup/reserve WiFi Web server and then go to loop()
         to handle connection requests
      */
      
      Serial.println("Setting Access Point...");
      WiFi.softAP(ssid, password);
      IPAddress IP = WiFi.softAPIP();
      Serial.print("ESP32 IP address: ");
      Serial.println(IP);
      Serial.println("ESP may now be connected to on this IP address");
      server.begin();
    }
}


void getReadings() {
    for (int x = 0; x < 10; x++) {
      // Temperature/Humidity values
      TempAndHumidity DhtValues = dht.getTempAndHumidity();
      
      // get current values from sensor
      temperature = DhtValues.temperature;  
      humidity = DhtValues.humidity;

      // add them up so average can be found later
      temperatureValues = temperatureValues + temperature;
      humidityValues = humidityValues + humidity;

      // Repeat with the remaining sensors
      // Dust sensor values
      dustSensorValue = dustsensor.getDustDensity();
      dustSensorValues = dustSensorValues + dustSensorValue;

      // Gas sensor values
      gasSensorValue = analogRead(MQgasSensorPin);
      gasSensorValPPM = map(gasSensorValue,0,3500,410,5000);
      gasSensorValues = gasSensorValues + gasSensorValue;
      
      delay(2000); // delay for 2 seconds so to have a sampling rate of
                   // 1 reading every 2 seconds.
    }

    // Get averages
    avTemperatureValue = temperatureValues/10;
    avHumidityValue = humidityValues/10;
    avDustSensorValue = dustSensorValues/10;
    avGasSensorValue = gasSensorValues/10;
        
    /* convert gas sensor value to PPM using calibrated value with mapping function in a realistic range
       when the gas sensor reading is 0, the level of CO2 in the air should be at 410PPM, the atmospheric level
       (this can be seen at https://www.co2.earth/). 
       Otherwise, when more CO2 or other pollutants are detected, the PPM value goes up along the mapping 
    */
    
    avGasSensorValuePPM = map(avGasSensorValue,0,3500,410,5000);

}

void do_send_wifi() {
    getReadings(); // from the sensors
    
    // send sensor readings to the feeds
    temperatureFeed->save(avTemperatureValue);
    humidityFeed->save(avHumidityValue);
    pollutantsFeed->save(avGasSensorValuePPM);
    dustFeed->save(avDustSensorValue);

    // reset the average/total sensor values to 0 
    // (otherwise it will only be done when put into deep-sleep mode)
    avTemperatureValue = 0;
    avHumidityValue = 0;
    avGasSensorValue = 0;
    avGasSensorValuePPM = 0;
    avDustSensorValue = 0;
    temperatureValues = 0;
    humidityValues = 0;
    dustSensorValues = 0;
    gasSensorValues = 0;
    
    delay(10000); // 10 second delay between WiFi readings
}

void do_send(osjob_t* j){
    // Send function for LoRa

    getReadings(); // from the sensors

  /* Unlike the other values, temperature might be a negative number. But,
     as the LMIC_setTxData2 function only supports unsigned integer values,
     we use the first byte of the sensor data array to denote whether the temperature
     is a negative or positive value. This byte will then be checked by the payload decoder
     on TheThingNetwork so that the temperature is corrected to the appropriate negative number
     if it happens to be negative, and sent on to AdafruitIO as usual
  */
  
    if (avTemperatureValue < 0) {
      mydata[0] = 1; // denote that temperature is negative
      avTemperatureValue = -avTemperatureValue; // convert temperature value to positive value for transmission 
                                                // (will be corrected on TTN console)
    } else {
      mydata[0] = 0; // otherwise denote positive
    }

    // divide the gas and dust sensor readings into low and high bytes for transmission
    byte dustByteLow = lowByte(avDustSensorValue);
    byte dustByteHigh = highByte(avDustSensorValue);
    byte gasByteLow = lowByte(avGasSensorValuePPM);
    byte gasByteHigh = highByte(avGasSensorValuePPM);

    // assign sensor readings to each 
    mydata[1] = avTemperatureValue;
    mydata[2] = avHumidityValue;
    mydata[3] = dustByteLow;
    mydata[4] = dustByteHigh;
    mydata[5] = gasByteLow;
    mydata[6] = gasByteHigh;

    // Check if there is not a current TX/RX job running
    if (LMIC.opmode & OP_TXRXPEND) {
        Serial.println(F("OP_TXRXPEND, not sending"));
    } else {
        // Prepare upstream data transmission at the next possible time.
        LMIC_setTxData2(1, mydata, sizeof(mydata)-1, 0);
        Serial.println(F("Packet queued"));
    }
    // Next TX is scheduled after TX_COMPLETE event.
}

void sleep() {
    Serial.println("ESP going to sleep...");
    delay(500);
    esp_sleep_enable_timer_wakeup(120 * 1000000); // 120 times 1000000 to convert microseconds -> 120 seconds
    esp_deep_sleep_start();
}


void serveWebPage() {
  /* Serve the web page to the user and perform Wifi-connecting functionalities
     according to the user input */
  
  WiFiClient client = server.available();     // Listen for incoming clients
  int counter = 1;                            // iterator for WiFi connection attempt

  if (client) {                               // If a new client connects,
    int networksFound = WiFi.scanNetworks();  // search for WiFi networks
    Serial.println("New Client.");            // print a message out in the serial port
    String currentLine = "";                  // make a String to hold incoming data from the client
    while (client.connected()) {              // loop while the client's connected
      if (client.available()) {               // if there's bytes to read from the client,
        char c = client.read();               // read a byte, then
        Serial.write(c);                      // print it out the serial monitor
        header += c;  
        if (c == '\n') {                    // if the byte is a newline character
          // if the current line is blank, you got two newline characters in a row.
          // that's the end of the client HTTP request, so send a response:
          if (currentLine.length() == 0) {
            // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK)
            // and a content-type so the client knows what's coming, then a blank line:
            client.println(" HTTP/1.1 200 OK");
            client.println("Content-type:text/html");
            client.println("Connection: close");
            client.println();

            // GET request handlers used to determine WiFi connectivity and HTML page appearance
            /* When WiFi and password fields are not included in the GET request, the header length is 469
               Thus we can use this to determine when the user has selected a WiFi network and input a password
            */
            if ((header.length() > 469) && (io.status() < AIO_CONNECTED)) {  
                // Get the WiFi and passwords from the GET request, after being selected by the user
                wifi_name = header.substring(header.indexOf("?network") + 9, header.indexOf("&password"));
                
                // spaces appear as + in GET requests, so must be corrected before using
                wifi_name.replace('+', ' ');
                wifi_pass = header.substring(header.indexOf("&password") + 10, header.indexOf("HTTP/1.1") - 1);
                Serial.println(wifi_name);
                Serial.println(wifi_pass);
  
                #define ADAFRUIT_WIFI_NAME       wifi_name.c_str()
                #define ADAFRUIT_WIFI_PASSWORD   wifi_pass.c_str()

                AdafruitIO_WiFi io(ADAFRUIT_IO_USER, ADAFRUIT_IO_KEY, ADAFRUIT_WIFI_NAME, ADAFRUIT_WIFI_PASSWORD); // connect to selected WiFi network
                io.connect();

                while ((io.status() < AIO_CONNECTED)  && (counter % 10 != 0)) { // give the ESP about 5 seconds to connect
                   Serial.println("...");
                   delay(500);   
                   counter+= 1;
                }

                Serial.println(io.statusText());
				        chipid=ESP.getEfuseMac();  // Get MAC address for the device
                Serial.printf("ESP32 Chip ID = %04X",(uint16_t)(chipid>>32));
                Serial.printf("%08X\n",(uint32_t)chipid);
                
            }

            // Display the HTML web page accordingly
            // If User taps the sleep button, send the ESP32 back to sleep and display a mini-page with notification to the user
            if (header.indexOf("/sleep") >= 0) {
                client.println("<!DOCTYPE html><html>");
                client.println("<head><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">");
                //client.println("<link rel=\"icon\" href=\"data:,\">");
                client.println("<body><script>alert('ESP32 now going to sleep...')</script></body></head></html>");
                // Shutdown the WiFi
                client.stop();
                delay(500);
                server.stop();
                delay(500);
                WiFi.disconnect(); 
                delay(500);
                sleep(); //sleep
            }

            // otherwise display full page
            client.println("<!DOCTYPE html><html>");
            client.println("<head><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">");
            //client.println("<link rel=\"icon\" href=\"data:,\">");
            // CSS to style the on/off buttons 
            // Feel free to change the background-color and font-size attributes to fit your preferences

            client.println("<style>body {width: 100%; text-align: center;}");
            client.println("#alert {color: red;}");
            client.println("#success {color: green;}");
            client.println("button, select, input {width: 200px; margin: 5px;}");
            client.println("form {padding-left: 15%; padding-right: 15%; text-align: center;}");
            client.println("label {text-align: left;}</style>");
            client.println("<title>Air Quality: WiFi Connection</title><meta charset='UTF-8'></head>");
                        
            // Web Page Heading
            client.println("<body><h1>Choose WiFi network</h1>");
            client.println("<p>Please select a WiFi network from the dropdown list to send air quality data with (if the network is open, leave the password field blank). To reset WiFi or go back to using LoRa, simply tap the Sleep button.</p>");
            client.println("<p>To start sending readings via WiFi,  close this page after you have connected the monitor to a network.</p>");

            if (io.status() == AIO_CONNECTED) { // if ESP is already connected to WiFi
                client.println("<p id='success'>Successfully connected to network!</p>");
                client.println("<a href= 'sleep'><button>Sleep</button></a>");
                counter = 1; // reset the iterator
                
            } else {         // otherwise if not
                if (counter > 1) { 
                  // If user has already tried to connect to WiFi without success
                  client.println("<p id='alert'>Invalid password or connection has been lost, please try again!</p>");
                }

                client.println("<form method=GET></br>Network:<select id='networks' name='network'>");

                for (int i = 0; i < networksFound; i++) {
                  String networkName = WiFi.SSID(i);
                  client.println("<option value='"+networkName+"'>"+networkName+"</option>");
                }
                
                client.println();
                client.println("</select>");
                client.println("</br>Password: <input type='password' name='password' placeholder='Password'/>");
                client.println("<br/><a href='connect'><button>Connect</button></form>");
                client.println("<a href= 'sleep'><button>Sleep</button></a>");

            }
            
            client.println("</body></html>");

            // The HTTP response ends with another blank line
            client.println();
            
            // Break out of the while loop
            break;
          } else { // if you got a newline, then clear currentLine
              currentLine = "";
          }
        
        } else if (c != '\r') {  // if you got anything else but a carriage return character,
          currentLine += c;      // add it to the end of the currentLine
        }
      }
    }
    
    // Clear the header variable
    header = "";
    // Close the connection
    client.stop();
    Serial.println("Client disconnected.");
    Serial.println("");
    
    }
}


void loop() {
  if (wifiOn == false) {
    sleep(); // If data was sent via LoRaWAN, then ESP32 can now sleep and cycle for another transmission
  } else {
    if (io.status() == AIO_CONNECTED) {
      io.run();
      do_send_wifi();
    }
    
    serveWebPage();

  }
}
