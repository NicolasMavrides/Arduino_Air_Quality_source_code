/* Off-grid Air Quality Monitor dissertation project 
   Source code for Prototype 3
   Written by Nicolas Mavrides, academic year 2018 - 19
   Supervised by Prof Hamish Cunningham
   Department of Computer Science

   Code written with the hep of borrowed examples from the Arduino-lmic library and
   COM3505 labs by Hamish Cunningham and ideas inspired by the following 
   Adafruit.com tutorial: https://learn.adafruit.com/the-things-network-for-feather
*/

#include <lmic.h>
#include <hal/hal.h>
#include <SPI.h>
#include <GP2Y1010_DustSensor.h> // Library for the Sharp dust sensor
#include <WiFi.h>
#include <WiFiClient.h>
#include <DHTesp.h>              // Library for temperature / humidity sensor 

GP2Y1010_DustSensor dustsensor;
DHTesp dht; // Declaring the Temperature and Humidity sensor

// Set up sensor pins and connection settings *****************************************
const int DustLEDPin = 21;
const int DustPin = 15;
const int dhtPin = 27;
const int MQgasSensorPin = 4;

// Set up WiFi connection credentials *************************************************
const char *ssid = "NETWORK_NAME";   // Network name redacted. Replace with available network...
const char *password = "PASSWORD";   // Password redacted. Replace with available network password...

// Device MAC address *****************************************************************
uint64_t chipid;                 // init uint for MAC address

// Sensor reading variables ***********************************************************
short gasSensorValue = 0;        // value read from gas sensor
int gasSensorValPPM = 0;         // gas sensor value after conversion to PPM
short dustSensorValue = 0;       // value read from dust sensor

short gasSensorValues = 0;       // sum of 10 gas sensor readings to get average
short dustSensorValues = 0;      // sum of 10 dust sensor readings to get average
  
short avGasSensorValue = 0;      // average of gasSensorValues
short avGasSensorValuePPM = 0;   // average of gasSensorValues
short avDustSensorValue = 0;     // average of dustSensorValues

int8_t temperature = 0;          // values read from temperature
int8_t humidity = 0;             // and humidity sensor

int temperatureValues = 0;       // sum of 10 temperature readings to get average
int humidityValues = 0;          // sum of 10 humidity readings to get average

int8_t avTemperatureValue = 0;   // average of temperatureValues
int8_t avHumidityValue = 0;      // average of humidityValues


// NOTE: NWKSKEY, APPSKEY AND DEVADDR REDACTED FOR SECURITY REASONS. REPLACE WITH CREDENTIALS GENERATED BY TTN APP TO BE USED
// LoRaWAN NwkSKey, network session key
static const PROGMEM u1_t NWKSKEY[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

// LoRaWAN AppSKey, application session key
static const u1_t PROGMEM APPSKEY[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

// LoRaWAN end-device address (DevAddr)
// See http://thethingsnetwork.org/wiki/AddressSpace
// The library converts the address to network byte order as needed.
static const u4_t DEVADDR = 0x00000000;

// These callbacks are only used in over-the-air activation, so they are
// left empty here (we cannot leave them out completely unless
// DISABLE_JOIN is set in arduino-lmic/project_config/lmic_project_config.h,
// otherwise the linker will complain).
void os_getArtEui (u1_t* buf) { }
void os_getDevEui (u1_t* buf) { }
void os_getDevKey (u1_t* buf) { }

static uint8_t mydata[8];
static osjob_t sendjob;

// Schedule TX every this many seconds (might become longer due to duty
// cycle limitations).
const unsigned TX_INTERVAL = 60;

// Pin mapping
// Adapted for Adafruit HUZZAH32
const lmic_pinmap lmic_pins = {
    .nss = A0,
    .rxtx = LMIC_UNUSED_PIN,
    .rst = A1,
    .dio = {39, 34, LMIC_UNUSED_PIN}, // using dio0 and dio1 radio pins
};

void onEvent (ev_t ev) {
    Serial.print(os_getTime());
    Serial.print(": ");
    switch(ev) {
        case EV_SCAN_TIMEOUT:
            Serial.println(F("EV_SCAN_TIMEOUT"));
            break;
        case EV_BEACON_FOUND:
            Serial.println(F("EV_BEACON_FOUND"));
            break;
        case EV_BEACON_MISSED:
            Serial.println(F("EV_BEACON_MISSED"));
            break;
        case EV_BEACON_TRACKED:
            Serial.println(F("EV_BEACON_TRACKED"));
            break;
        case EV_JOINING:
            Serial.println(F("EV_JOINING"));
            break;
        case EV_JOINED:
            Serial.println(F("EV_JOINED"));
            break;
        case EV_JOIN_FAILED:
            Serial.println(F("EV_JOIN_FAILED"));
            break;
        case EV_REJOIN_FAILED:
            Serial.println(F("EV_REJOIN_FAILED"));
            break;
        case EV_TXCOMPLETE:
            Serial.println(F("EV_TXCOMPLETE (includes waiting for RX windows)"));
            if (LMIC.txrxFlags & TXRX_ACK)
              Serial.println(F("Received ack"));
            if (LMIC.dataLen) {
              Serial.println(F("Received "));
              Serial.println(LMIC.dataLen);
              Serial.println(F(" bytes of payload"));
            }
            // Schedule next transmission
            os_setTimedCallback(&sendjob, os_getTime()+sec2osticks(TX_INTERVAL), do_send);
            break;
        case EV_LOST_TSYNC:
            Serial.println(F("EV_LOST_TSYNC"));
            break;
        case EV_RESET:
            Serial.println(F("EV_RESET"));
            break;
        case EV_RXCOMPLETE:
            // data received in ping slot
            Serial.println(F("EV_RXCOMPLETE"));
            break;
        case EV_LINK_DEAD:
            Serial.println(F("EV_LINK_DEAD"));
            break;
        case EV_LINK_ALIVE:
            Serial.println(F("EV_LINK_ALIVE"));
            break;
      } 
}


void setup() {
    delay(2000); // "nudge" time for ESP to wake up after deep-sleep
    
    while (!Serial); // wait for Serial to be initialized
    Serial.begin(115200);
    //delay(100);     // per sample code on RF_95 test
    Serial.println(F("Starting"));

    // Sensors init
    dht.setup(dhtPin, DHTesp::AM2302);  
    dustsensor.begin(DustLEDPin, DustPin);
    dustsensor.setInputVolts(5);   // Voltage for dust sensor set to 5V
    dustsensor.setADCbit(12);      // ADCbit set to 12 bits as we are using ESP32

    // LMIC init
    Serial.println("os initialising...");
    os_init();
    Serial.println("os init complete!");
    // Reset the MAC state. Session and pending data transfers will be discarded.
    LMIC_reset();

    // Set static session parameters. Instead of dynamically establishing a session
    // by joining the network, precomputed session parameters are be provided.
    #ifdef PROGMEM
    // On AVR, these values are stored in flash and only copied to RAM
    // once. Copy them to a temporary buffer here, LMIC_setSession will
    // copy them into a buffer of its own again.
    uint8_t appskey[sizeof(APPSKEY)];
    uint8_t nwkskey[sizeof(NWKSKEY)];
    memcpy_P(appskey, APPSKEY, sizeof(APPSKEY));
    memcpy_P(nwkskey, NWKSKEY, sizeof(NWKSKEY));
    LMIC_setSession (0x13, DEVADDR, nwkskey, appskey);
    #else
    // If not running an AVR with PROGMEM, just use the arrays directly
    LMIC_setSession (0x13, DEVADDR, NWKSKEY, APPSKEY);
    #endif
    
    #if defined(CFG_eu868)  // Check if the EU config settings are set
    // (Region-specific config settings are set in the lmic library)
    // Set up the channels used by the Things Network, which corresponds
    // to the defaults of most gateways. Without this, only three base
    // channels from the LoRaWAN specification are used, which certainly
    // works, so it is good for debugging, but can overload those
    // frequencies, so be sure to configure the full frequency range of
    // your network here (unless your network autoconfigures them).
    // Setting up channels should happen after LMIC_setSession, as that
    // configures the minimal channel set.
    Serial.println("EU region configuration specified.");
    
    LMIC_setupChannel(0, 868100000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
    LMIC_setupChannel(1, 868300000, DR_RANGE_MAP(DR_SF12, DR_SF7B), BAND_CENTI);      // g-band
    LMIC_setupChannel(2, 868500000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
    LMIC_setupChannel(3, 867100000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
    LMIC_setupChannel(4, 867300000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
    LMIC_setupChannel(5, 867500000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
    LMIC_setupChannel(6, 867700000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
    LMIC_setupChannel(7, 867900000, DR_RANGE_MAP(DR_SF12, DR_SF7),  BAND_CENTI);      // g-band
    LMIC_setupChannel(8, 868800000, DR_RANGE_MAP(DR_FSK,  DR_FSK),  BAND_MILLI);      // g2-band
    
    // TTN defines an additional channel at 869.525Mhz using SF9 for class B
    // devices' ping slots. LMIC does not have an easy way to define set this
    // frequency and support for class B is spotty and untested, so this
    // frequency is not configured here.
    #elif defined(CFG_us915)
    // NA-US channels 0-71 are configured automatically
    // but only one group of 8 should (a subband) should be active
    // TTN recommends the second sub band, 1 in a zero based count.
    // https://github.com/TheThingsNetwork/gateway-conf/blob/master/US-global_conf.json
    LMIC_selectSubBand(1);
    #endif
    
    // Disable link check validation
    LMIC_setLinkCheckMode(0);

    // TTN uses SF9 for its RX2 window.
    LMIC.dn2Dr = DR_SF9;

    // Set data rate and transmit power for uplink (note: txpow seems to be ignored by the library)
    LMIC_setDrTxpow(DR_SF7,14);

    // Start job
    do_send(&sendjob);
}


void do_send(osjob_t* j){
    for (int x = 0; x < 10; x++) {
      // Temperature/Humidity values
      TempAndHumidity DhtValues = dht.getTempAndHumidity();

      // get current values from sensor
      temperature = DhtValues.temperature;  
      humidity = DhtValues.humidity;
      
      // add them up so average can be found later
      temperatureValues = temperatureValues + temperature;
      humidityValues = humidityValues + humidity;

      // Repeat with the remaining sensors
      // Dust sensor values
      dustSensorValue = dustsensor.getDustDensity();
      dustSensorValues = dustSensorValues + dustSensorValue;

      // Gas sensor values
      gasSensorValue = analogRead(MQgasSensorPin);
      gasSensorValPPM = map(gasSensorValue,0,3500,410,5000);
      gasSensorValues = gasSensorValues + gasSensorValue;

      delay(2000); // delay for 2 seconds so to have a sampling rate of
                   // 1 reading every 2 seconds.
    }

    // Get averages
    avTemperatureValue = temperatureValues/10;
    avHumidityValue = humidityValues/10;
    avDustSensorValue = dustSensorValues/10;
    avGasSensorValue = gasSensorValues/10;

    // convert gas sensor value to PPM using calibrated value with mapping function in a realistic range
    // when the gas sensor reading is 0, the level of CO2 in the air should be at 410PPM, the atmospheric level
    // otherwise, when more CO2 or other pollutants are detected, the PPM value goes up along the mapping
    avGasSensorValuePPM = map(avGasSensorValue,0,3500,410,5000);

    /* Unlike the other values, temperature might be a negative number. But,
       as the LMIC_setTxData2 function only supports unsigned integer values,
       we use the first byte of the sensor data array to denote whether the temperature
       is a negative or positive value. This byte will then be checked by the payload decoder
       on TheThingNetwork so that the temperature is corrected to the appropriate negative number
       if it happens to be negative, and sent on to AdafruitIO as usual
    */

    if (avTemperatureValue < 0) {
      mydata[0] = 1; // denote that temperature is negative
      avTemperatureValue = -avTemperatureValue; // convert temperature value to positive value for transmission 
                                                // (will be corrected on TTN console)
    } else {
      mydata[0] = 0; // otherwise denote positive
    }

    // divide the gas and dust sensor readings into low and high bytes for transmission
    byte dustByteLow = lowByte(avDustSensorValue);
    byte dustByteHigh = highByte(avDustSensorValue);
    byte gasByteLow = lowByte(avGasSensorValuePPM);
    byte gasByteHigh = highByte(avGasSensorValuePPM);

    // assign sensor readings to each 
    mydata[1] = avTemperatureValue;
    mydata[2] = avHumidityValue;
    mydata[3] = dustByteLow;
    mydata[4] = dustByteHigh;
    mydata[5] = gasByteLow;
    mydata[6] = gasByteHigh;

    // Check if there is not a current TX/RX job running
    if (LMIC.opmode & OP_TXRXPEND) {
        Serial.println(F("OP_TXRXPEND, not sending"));
    } else {
        // Prepare upstream data transmission at the next possible time.
        LMIC_setTxData2(1, mydata, sizeof(mydata)-1, 0);
        Serial.println(F("Packet queued"));
    }
    // Next TX is scheduled after TX_COMPLETE event.
}

void loop() {   
  Serial.println("ESP going to sleep...");
  delay(500); // wait half a second
  esp_sleep_enable_timer_wakeup(120 * 1000000); // 120 times 1000000 to convert microseconds -> 120 seconds
  esp_deep_sleep_start();
  
  // Nothing below this line can be called due to deep-sleep. ESP will reboot and call setup() again.
    
}
